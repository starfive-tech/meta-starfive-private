From 265b6bca394b728ff31a46ee8c4c0ccce23b43fc Mon Sep 17 00:00:00 2001
From: "Maciej W. Rozycki" <macro@embecosm.com>
Date: Wed, 22 Nov 2023 01:18:30 +0000
Subject: [PATCH 26/30] RISC-V: Provide FP conditional-branch instructions for
 if-conversion

Do not expand floating-point conditional-branch RTL instructions right
away that use a comparison operation that is either directly available
as a machine conditional-set instruction or is NE, which can be emulated
by EQ.  This is so that if-conversion sees them in their original form
and can produce fewer operations tried in a branchless code sequence
compared to when such an instruction has been already converted to a
sequence of a floating-point conditional-set RTL instruction followed by
an integer conditional-branch RTL instruction.  Split any floating-point
conditional-branch RTL instructions still remaining after reload then.

Adjust the testsuite accordingly: since the middle end uses the inverse
condition internally, an inverse conditional-set instruction may make it
to assembly output and also `cond_move_process_if_block' will be used by
if-conversion rather than `noce_process_if_block', because the latter
function not yet been updated to handle inverted conditions.

	gcc/
	* config/riscv/predicates.md (ne_operator): New predicate.
	* config/riscv/riscv.cc (riscv_insn_cost): Handle branches on a
	floating-point condition.
	* config/riscv/riscv.md (@cbranch<mode>4): Rename expander to...
	(@cbranch<ANYF:mode>4): ... this.  Only expand the RTX via
	`riscv_expand_conditional_branch' for `!signed_order_operator'
	operators, otherwise let it through.
	(*cbranch<ANYF:mode>4, *cbranch<ANYF:mode>4): New insns and
	splitters.

	gcc/testsuite/
	* gcc.target/riscv/movdifge-sfb.c: Reject "if-conversion
	succeeded through" rather than accepting it.
	* gcc.target/riscv/movdifge-thead.c: Likewise.
	* gcc.target/riscv/movdifge-ventana.c: Likewise.
	* gcc.target/riscv/movdifge-zicond.c: Likewise.
	* gcc.target/riscv/movdifgt-sfb.c: Likewise.
	* gcc.target/riscv/movdifgt-thead.c: Likewise.
	* gcc.target/riscv/movdifgt-ventana.c: Likewise.
	* gcc.target/riscv/movdifgt-zicond.c: Likewise.
	* gcc.target/riscv/movdifle-sfb.c: Likewise.
	* gcc.target/riscv/movdifle-thead.c: Likewise.
	* gcc.target/riscv/movdifle-ventana.c: Likewise.
	* gcc.target/riscv/movdifle-zicond.c: Likewise.
	* gcc.target/riscv/movdiflt-sfb.c: Likewise.
	* gcc.target/riscv/movdiflt-thead.c: Likewise.
	* gcc.target/riscv/movdiflt-ventana.c: Likewise.
	* gcc.target/riscv/movdiflt-zicond.c: Likewise.
	* gcc.target/riscv/movsifge-sfb.c: Likewise.
	* gcc.target/riscv/movsifge-thead.c: Likewise.
	* gcc.target/riscv/movsifge-ventana.c: Likewise.
	* gcc.target/riscv/movsifge-zicond.c: Likewise.
	* gcc.target/riscv/movsifgt-sfb.c: Likewise.
	* gcc.target/riscv/movsifgt-thead.c: Likewise.
	* gcc.target/riscv/movsifgt-ventana.c: Likewise.
	* gcc.target/riscv/movsifgt-zicond.c: Likewise.
	* gcc.target/riscv/movsifle-sfb.c: Likewise.
	* gcc.target/riscv/movsifle-thead.c: Likewise.
	* gcc.target/riscv/movsifle-ventana.c: Likewise.
	* gcc.target/riscv/movsifle-zicond.c: Likewise.
	* gcc.target/riscv/movsiflt-sfb.c: Likewise.
	* gcc.target/riscv/movsiflt-thead.c: Likewise.
	* gcc.target/riscv/movsiflt-ventana.c: Likewise.
	* gcc.target/riscv/movsiflt-zicond.c: Likewise.
	* gcc.target/riscv/smax-ieee.c: Also accept FLT.D.
	* gcc.target/riscv/smaxf-ieee.c: Also accept FLT.S.
	* gcc.target/riscv/smin-ieee.c: Also accept FGT.D.
	* gcc.target/riscv/sminf-ieee.c: Also accept FGT.S.
---
 gcc/config/riscv/predicates.md                |  3 +
 gcc/config/riscv/riscv.cc                     | 22 +++--
 gcc/config/riscv/riscv.md                     | 89 ++++++++++++++++---
 gcc/testsuite/gcc.target/riscv/movdifge-sfb.c | 26 ++++++
 .../gcc.target/riscv/movdifge-thead.c         | 25 ++++++
 .../gcc.target/riscv/movdifge-ventana.c       | 28 ++++++
 .../gcc.target/riscv/movdifge-zicond.c        | 28 ++++++
 gcc/testsuite/gcc.target/riscv/movdifgt-sfb.c | 26 ++++++
 .../gcc.target/riscv/movdifgt-thead.c         | 25 ++++++
 .../gcc.target/riscv/movdifgt-ventana.c       | 28 ++++++
 .../gcc.target/riscv/movdifgt-zicond.c        | 28 ++++++
 gcc/testsuite/gcc.target/riscv/movdifle-sfb.c | 26 ++++++
 .../gcc.target/riscv/movdifle-thead.c         | 25 ++++++
 .../gcc.target/riscv/movdifle-ventana.c       | 28 ++++++
 .../gcc.target/riscv/movdifle-zicond.c        | 28 ++++++
 gcc/testsuite/gcc.target/riscv/movdiflt-sfb.c | 26 ++++++
 .../gcc.target/riscv/movdiflt-thead.c         | 25 ++++++
 .../gcc.target/riscv/movdiflt-ventana.c       | 28 ++++++
 .../gcc.target/riscv/movdiflt-zicond.c        | 28 ++++++
 gcc/testsuite/gcc.target/riscv/movsifge-sfb.c | 26 ++++++
 .../gcc.target/riscv/movsifge-thead.c         | 25 ++++++
 .../gcc.target/riscv/movsifge-ventana.c       | 28 ++++++
 .../gcc.target/riscv/movsifge-zicond.c        | 28 ++++++
 gcc/testsuite/gcc.target/riscv/movsifgt-sfb.c | 26 ++++++
 .../gcc.target/riscv/movsifgt-thead.c         | 25 ++++++
 .../gcc.target/riscv/movsifgt-ventana.c       | 28 ++++++
 .../gcc.target/riscv/movsifgt-zicond.c        | 28 ++++++
 gcc/testsuite/gcc.target/riscv/movsifle-sfb.c | 26 ++++++
 .../gcc.target/riscv/movsifle-thead.c         | 25 ++++++
 .../gcc.target/riscv/movsifle-ventana.c       | 28 ++++++
 .../gcc.target/riscv/movsifle-zicond.c        | 28 ++++++
 gcc/testsuite/gcc.target/riscv/movsiflt-sfb.c | 26 ++++++
 .../gcc.target/riscv/movsiflt-thead.c         | 25 ++++++
 .../gcc.target/riscv/movsiflt-ventana.c       | 28 ++++++
 .../gcc.target/riscv/movsiflt-zicond.c        | 28 ++++++
 gcc/testsuite/gcc.target/riscv/smax-ieee.c    |  2 +-
 gcc/testsuite/gcc.target/riscv/smaxf-ieee.c   |  2 +-
 gcc/testsuite/gcc.target/riscv/smin-ieee.c    |  2 +-
 gcc/testsuite/gcc.target/riscv/sminf-ieee.c   |  2 +-
 39 files changed, 958 insertions(+), 20 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifge-sfb.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifge-thead.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifge-ventana.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifge-zicond.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifgt-sfb.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifgt-thead.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifgt-ventana.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifgt-zicond.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifle-sfb.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifle-thead.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifle-ventana.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdifle-zicond.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdiflt-sfb.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdiflt-thead.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdiflt-ventana.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movdiflt-zicond.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifge-sfb.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifge-thead.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifge-ventana.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifge-zicond.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifgt-sfb.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifgt-thead.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifgt-ventana.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifgt-zicond.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifle-sfb.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifle-thead.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifle-ventana.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsifle-zicond.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsiflt-sfb.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsiflt-thead.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsiflt-ventana.c
 create mode 100644 gcc/testsuite/gcc.target/riscv/movsiflt-zicond.c

diff --git a/gcc/config/riscv/predicates.md b/gcc/config/riscv/predicates.md
index 8654dbc5943..e7d4738ac28 100644
--- a/gcc/config/riscv/predicates.md
+++ b/gcc/config/riscv/predicates.md
@@ -197,6 +197,9 @@
 (define_predicate "modular_operator"
   (match_code "plus,minus,mult,ashift"))
 
+(define_predicate "ne_operator"
+  (match_code "ne"))
+
 (define_predicate "equality_operator"
   (match_code "eq,ne"))
 
diff --git a/gcc/config/riscv/riscv.cc b/gcc/config/riscv/riscv.cc
index 6ed3c2d1d1d..050dce9c4e5 100644
--- a/gcc/config/riscv/riscv.cc
+++ b/gcc/config/riscv/riscv.cc
@@ -2773,7 +2773,9 @@ riscv_address_cost (rtx addr, machine_mode mode,
    calculation for conditional branches: one unit is considered the cost
    of microarchitecture-dependent actual branch execution and therefore
    multiplied by BRANCH_COST and any remaining units are considered fixed
-   branch overhead.  */
+   branch overhead.  Branches on a floating-point condition incur an extra
+   instruction cost as they will be split into an FCMP operation followed
+   by a branch on an integer condition.  */
 
 static int
 riscv_insn_cost (rtx_insn *insn, bool speed)
@@ -2781,11 +2783,19 @@ riscv_insn_cost (rtx_insn *insn, bool speed)
   rtx x = PATTERN (insn);
   int cost = pattern_cost (x, speed);
 
-  if (JUMP_P (insn)
-      && GET_CODE (x) == SET
-      && GET_CODE (SET_DEST (x)) == PC
-      && GET_CODE (SET_SRC (x)) == IF_THEN_ELSE)
-    cost += COSTS_N_INSNS (BRANCH_COST (speed, false) - 1);
+  if (JUMP_P (insn))
+    {
+      if (GET_CODE (x) == PARALLEL)
+	x = XVECEXP (x, 0, 0);
+      if (GET_CODE (x) == SET
+	  && GET_CODE (SET_DEST (x)) == PC
+	  && GET_CODE (SET_SRC (x)) == IF_THEN_ELSE)
+	{
+	  cost += COSTS_N_INSNS (BRANCH_COST (speed, false) - 1);
+	  if (FLOAT_MODE_P (GET_MODE (XEXP (XEXP (SET_SRC (x), 0), 0))))
+	    cost += COSTS_N_INSNS (1);
+	}
+    }
   return cost;
 }
 
diff --git a/gcc/config/riscv/riscv.md b/gcc/config/riscv/riscv.md
index d965f4a2c5d..0d15263fb24 100644
--- a/gcc/config/riscv/riscv.md
+++ b/gcc/config/riscv/riscv.md
@@ -2372,20 +2372,89 @@
   DONE;
 })
 
-(define_expand "@cbranch<mode>4"
-  [(set (pc)
-	(if_then_else (match_operator 0 "fp_branch_comparison"
-		       [(match_operand:ANYF 1 "register_operand")
-			(match_operand:ANYF 2 "register_operand")])
-		      (label_ref (match_operand 3 ""))
-		      (pc)))]
+(define_expand "@cbranch<ANYF:mode>4"
+  [(parallel [(set (pc)
+		   (if_then_else (match_operator 0 "fp_branch_comparison"
+				  [(match_operand:ANYF 1 "register_operand")
+				   (match_operand:ANYF 2 "register_operand")])
+				 (label_ref (match_operand 3 ""))
+				 (pc)))
+	      (clobber (match_operand 4 ""))])]
   "TARGET_HARD_FLOAT || TARGET_ZFINX"
 {
-  riscv_expand_conditional_branch (operands[3], GET_CODE (operands[0]),
-				   operands[1], operands[2]);
-  DONE;
+  if (!signed_order_operator (operands[0], GET_MODE (operands[0])))
+    {
+      riscv_expand_conditional_branch (operands[3], GET_CODE (operands[0]),
+				       operands[1], operands[2]);
+      DONE;
+    }
+  operands[4] = gen_reg_rtx (TARGET_64BIT ? DImode : SImode);
 })
 
+(define_insn_and_split "*cbranch<ANYF:mode>4"
+  [(set (pc)
+	(if_then_else (match_operator 1 "fp_native_comparison"
+		       [(match_operand:ANYF 2 "register_operand" "f")
+			(match_operand:ANYF 3 "register_operand" "f")])
+		      (label_ref (match_operand 0 ""))
+		      (pc)))
+   (clobber (match_operand:X 4 "register_operand" "=r"))]
+  "TARGET_HARD_FLOAT || TARGET_ZFINX"
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 4)
+	(match_op_dup:X 1 [(match_dup 2) (match_dup 3)]))
+   (set (pc)
+	(if_then_else (ne:X (match_dup 4) (const_int 0))
+		      (label_ref (match_operand 0))
+		      (pc)))]
+  ""
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(if_then_else (and (le (minus (match_dup 0) (pc))
+			       (const_int 4084))
+			   (le (minus (pc) (match_dup 0))
+			       (const_int 4096)))
+		      (const_int 8)
+		      (if_then_else (and (le (minus (match_dup 0) (pc))
+					     (const_int 1048564))
+					 (le (minus (pc) (match_dup 0))
+					     (const_int 1048576)))
+				    (const_int 12)
+				    (const_int 16))))])
+
+(define_insn_and_split "*cbranch<ANYF:mode>4"
+  [(set (pc)
+	(if_then_else (match_operator 1 "ne_operator"
+		       [(match_operand:ANYF 2 "register_operand" "f")
+			(match_operand:ANYF 3 "register_operand" "f")])
+		      (label_ref (match_operand 0 ""))
+		      (pc)))
+   (clobber (match_operand:X 4 "register_operand" "=r"))]
+  "TARGET_HARD_FLOAT || TARGET_ZFINX"
+  "#"
+  "&& reload_completed"
+  [(set (match_dup 4)
+	(eq:X (match_dup 2) (match_dup 3)))
+   (set (pc)
+	(if_then_else (eq:X (match_dup 4) (const_int 0))
+		      (label_ref (match_operand 0))
+		      (pc)))]
+  ""
+  [(set_attr "type" "branch")
+   (set (attr "length")
+	(if_then_else (and (le (minus (match_dup 0) (pc))
+			       (const_int 4084))
+			   (le (minus (pc) (match_dup 0))
+			       (const_int 4096)))
+		      (const_int 8)
+		      (if_then_else (and (le (minus (match_dup 0) (pc))
+					     (const_int 1048564))
+					 (le (minus (pc) (match_dup 0))
+					     (const_int 1048576)))
+				    (const_int 12)
+				    (const_int 16))))])
+
 (define_insn_and_split "*branch_on_bit<X:mode>"
   [(set (pc)
 	(if_then_else
diff --git a/gcc/testsuite/gcc.target/riscv/movdifge-sfb.c b/gcc/testsuite/gcc.target/riscv/movdifge-sfb.c
new file mode 100644
index 00000000000..b5eb0f40dff
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifge-sfb.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifge (double w, double x, int_t y, int_t z)
+{
+  return w >= x ? y : z;
+}
+
+/* Expect short forward branch assembly like:
+
+	fge.d	a5,fa0,fa1
+	bne	a5,zero,1f	# movcc
+	mv	a0,a1
+1:
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:beq|bne)\\s\[^\\s\]+\\s# movcc\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifge-thead.c b/gcc/testsuite/gcc.target/riscv/movdifge-thead.c
new file mode 100644
index 00000000000..6fb210ccc8d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifge-thead.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifge (double w, double x, int_t y, int_t z)
+{
+  return w >= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fge.d	a5,fa0,fa1
+	th.mveqz	a0,a1,a5
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:th\\.mveqz|th\\.mvnez)\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifge-ventana.c b/gcc/testsuite/gcc.target/riscv/movdifge-ventana.c
new file mode 100644
index 00000000000..be33171d109
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifge-ventana.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_xventanacondops -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifge (double w, double x, int_t y, int_t z)
+{
+  return w >= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fge.d	a5,fa0,fa1
+	vt.maskc	a0,a0,a5
+	vt.maskcn	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskc\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskcn\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifge-zicond.c b/gcc/testsuite/gcc.target/riscv/movdifge-zicond.c
new file mode 100644
index 00000000000..0c6a10fee28
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifge-zicond.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifge (double w, double x, int_t y, int_t z)
+{
+  return w >= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fge.d	a5,fa0,fa1
+	czero.eqz	a0,a0,a5
+	czero.nez	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.eqz\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.nez\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifgt-sfb.c b/gcc/testsuite/gcc.target/riscv/movdifgt-sfb.c
new file mode 100644
index 00000000000..0fc5a1caa62
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifgt-sfb.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifgt (double w, double x, int_t y, int_t z)
+{
+  return w > x ? y : z;
+}
+
+/* Expect short forward branch assembly like:
+
+	fgt.d	a5,fa0,fa1
+	bne	a5,zero,1f	# movcc
+	mv	a0,a1
+1:
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:beq|bne)\\s\[^\\s\]+\\s# movcc\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifgt-thead.c b/gcc/testsuite/gcc.target/riscv/movdifgt-thead.c
new file mode 100644
index 00000000000..1eece07afcd
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifgt-thead.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifgt (double w, double x, int_t y, int_t z)
+{
+  return w > x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fgt.d	a5,fa0,fa1
+	th.mveqz	a0,a1,a5
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:th\\.mveqz|th\\.mvnez)\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifgt-ventana.c b/gcc/testsuite/gcc.target/riscv/movdifgt-ventana.c
new file mode 100644
index 00000000000..7df01a64952
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifgt-ventana.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_xventanacondops -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifgt (double w, double x, int_t y, int_t z)
+{
+  return w > x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fgt.d	a5,fa0,fa1
+	vt.maskc	a0,a0,a5
+	vt.maskcn	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskc\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskcn\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifgt-zicond.c b/gcc/testsuite/gcc.target/riscv/movdifgt-zicond.c
new file mode 100644
index 00000000000..6b18e8f4678
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifgt-zicond.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifgt (double w, double x, int_t y, int_t z)
+{
+  return w > x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fgt.d	a5,fa0,fa1
+	czero.eqz	a0,a0,a5
+	czero.nez	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.eqz\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.nez\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifle-sfb.c b/gcc/testsuite/gcc.target/riscv/movdifle-sfb.c
new file mode 100644
index 00000000000..475c7f2d25a
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifle-sfb.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifle (double w, double x, int_t y, int_t z)
+{
+  return w <= x ? y : z;
+}
+
+/* Expect short forward branch assembly like:
+
+	fle.d	a5,fa0,fa1
+	bne	a5,zero,1f	# movcc
+	mv	a0,a1
+1:
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:beq|bne)\\s\[^\\s\]+\\s# movcc\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifle-thead.c b/gcc/testsuite/gcc.target/riscv/movdifle-thead.c
new file mode 100644
index 00000000000..9ee0dbb7da4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifle-thead.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifle (double w, double x, int_t y, int_t z)
+{
+  return w <= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fle.d	a5,fa0,fa1
+	th.mveqz	a0,a1,a5
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:th\\.mveqz|th\\.mvnez)\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifle-ventana.c b/gcc/testsuite/gcc.target/riscv/movdifle-ventana.c
new file mode 100644
index 00000000000..d6f67ae940d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifle-ventana.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_xventanacondops -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifle (double w, double x, int_t y, int_t z)
+{
+  return w <= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fle.d	a5,fa0,fa1
+	vt.maskc	a0,a0,a5
+	vt.maskcn	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskc\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskcn\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdifle-zicond.c b/gcc/testsuite/gcc.target/riscv/movdifle-zicond.c
new file mode 100644
index 00000000000..c1f13b7f5dc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdifle-zicond.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdifle (double w, double x, int_t y, int_t z)
+{
+  return w <= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fle.d	a5,fa0,fa1
+	czero.eqz	a0,a0,a5
+	czero.nez	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.eqz\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.nez\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdiflt-sfb.c b/gcc/testsuite/gcc.target/riscv/movdiflt-sfb.c
new file mode 100644
index 00000000000..c116fe315b4
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdiflt-sfb.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdiflt (double w, double x, int_t y, int_t z)
+{
+  return w < x ? y : z;
+}
+
+/* Expect short forward branch assembly like:
+
+	flt.d	a5,fa0,fa1
+	bne	a5,zero,1f	# movcc
+	mv	a0,a1
+1:
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:beq|bne)\\s\[^\\s\]+\\s# movcc\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdiflt-thead.c b/gcc/testsuite/gcc.target/riscv/movdiflt-thead.c
new file mode 100644
index 00000000000..f4f210c02a9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdiflt-thead.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdiflt (double w, double x, int_t y, int_t z)
+{
+  return w < x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	flt.d	a5,fa0,fa1
+	th.mveqz	a0,a1,a5
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:th\\.mveqz|th\\.mvnez)\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdiflt-ventana.c b/gcc/testsuite/gcc.target/riscv/movdiflt-ventana.c
new file mode 100644
index 00000000000..049b77c2b8b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdiflt-ventana.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_xventanacondops -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdiflt (double w, double x, int_t y, int_t z)
+{
+  return w < x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	flt.d	a5,fa0,fa1
+	vt.maskc	a0,a0,a5
+	vt.maskcn	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskc\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskcn\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movdiflt-zicond.c b/gcc/testsuite/gcc.target/riscv/movdiflt-zicond.c
new file mode 100644
index 00000000000..6a1d7cea19f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movdiflt-zicond.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (DI))) int_t;
+
+int_t
+movdiflt (double w, double x, int_t y, int_t z)
+{
+  return w < x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	flt.d	a5,fa0,fa1
+	czero.eqz	a0,a0,a5
+	czero.nez	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.eqz\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.nez\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifge-sfb.c b/gcc/testsuite/gcc.target/riscv/movsifge-sfb.c
new file mode 100644
index 00000000000..c9f0e2dfa50
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifge-sfb.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifge (double w, double x, int_t y, int_t z)
+{
+  return w >= x ? y : z;
+}
+
+/* Expect short forward branch assembly like:
+
+	fge.d	a5,fa0,fa1
+	bne	a5,zero,1f	# movcc
+	mv	a0,a1
+1:
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:beq|bne)\\s\[^\\s\]+\\s# movcc\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifge-thead.c b/gcc/testsuite/gcc.target/riscv/movsifge-thead.c
new file mode 100644
index 00000000000..893a522ac5f
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifge-thead.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifge (double w, double x, int_t y, int_t z)
+{
+  return w >= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fge.d	a5,fa0,fa1
+	th.mveqz	a0,a1,a5
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:th\\.mveqz|th\\.mvnez)\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifge-ventana.c b/gcc/testsuite/gcc.target/riscv/movsifge-ventana.c
new file mode 100644
index 00000000000..26e55b6d867
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifge-ventana.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_xventanacondops -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifge (double w, double x, int_t y, int_t z)
+{
+  return w >= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fge.d	a5,fa0,fa1
+	vt.maskc	a0,a0,a5
+	vt.maskcn	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskc\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskcn\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifge-zicond.c b/gcc/testsuite/gcc.target/riscv/movsifge-zicond.c
new file mode 100644
index 00000000000..e38aa80bf0d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifge-zicond.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifge (double w, double x, int_t y, int_t z)
+{
+  return w >= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fge.d	a5,fa0,fa1
+	czero.eqz	a0,a0,a5
+	czero.nez	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.eqz\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.nez\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifgt-sfb.c b/gcc/testsuite/gcc.target/riscv/movsifgt-sfb.c
new file mode 100644
index 00000000000..47ea2c2149d
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifgt-sfb.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifgt (double w, double x, int_t y, int_t z)
+{
+  return w > x ? y : z;
+}
+
+/* Expect short forward branch assembly like:
+
+	fgt.d	a5,fa0,fa1
+	bne	a5,zero,1f	# movcc
+	mv	a0,a1
+1:
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:beq|bne)\\s\[^\\s\]+\\s# movcc\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifgt-thead.c b/gcc/testsuite/gcc.target/riscv/movsifgt-thead.c
new file mode 100644
index 00000000000..0ec4e575f87
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifgt-thead.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifgt (double w, double x, int_t y, int_t z)
+{
+  return w > x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fgt.d	a5,fa0,fa1
+	th.mveqz	a0,a1,a5
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:th\\.mveqz|th\\.mvnez)\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifgt-ventana.c b/gcc/testsuite/gcc.target/riscv/movsifgt-ventana.c
new file mode 100644
index 00000000000..8896266e243
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifgt-ventana.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_xventanacondops -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifgt (double w, double x, int_t y, int_t z)
+{
+  return w > x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fgt.d	a5,fa0,fa1
+	vt.maskc	a0,a0,a5
+	vt.maskcn	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskc\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskcn\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifgt-zicond.c b/gcc/testsuite/gcc.target/riscv/movsifgt-zicond.c
new file mode 100644
index 00000000000..bada72f44d8
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifgt-zicond.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifgt (double w, double x, int_t y, int_t z)
+{
+  return w > x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fgt.d	a5,fa0,fa1
+	czero.eqz	a0,a0,a5
+	czero.nez	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.eqz\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.nez\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifle-sfb.c b/gcc/testsuite/gcc.target/riscv/movsifle-sfb.c
new file mode 100644
index 00000000000..7cb9167cd13
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifle-sfb.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifle (double w, double x, int_t y, int_t z)
+{
+  return w <= x ? y : z;
+}
+
+/* Expect short forward branch assembly like:
+
+	fle.d	a5,fa0,fa1
+	bne	a5,zero,1f	# movcc
+	mv	a0,a1
+1:
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:beq|bne)\\s\[^\\s\]+\\s# movcc\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifle-thead.c b/gcc/testsuite/gcc.target/riscv/movsifle-thead.c
new file mode 100644
index 00000000000..b05a02a44f9
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifle-thead.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifle (double w, double x, int_t y, int_t z)
+{
+  return w <= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fle.d	a5,fa0,fa1
+	th.mveqz	a0,a1,a5
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:th\\.mveqz|th\\.mvnez)\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifle-ventana.c b/gcc/testsuite/gcc.target/riscv/movsifle-ventana.c
new file mode 100644
index 00000000000..24b49d9dffc
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifle-ventana.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_xventanacondops -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifle (double w, double x, int_t y, int_t z)
+{
+  return w <= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fle.d	a5,fa0,fa1
+	vt.maskc	a0,a0,a5
+	vt.maskcn	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskc\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskcn\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsifle-zicond.c b/gcc/testsuite/gcc.target/riscv/movsifle-zicond.c
new file mode 100644
index 00000000000..5aad91007ea
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsifle-zicond.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsifle (double w, double x, int_t y, int_t z)
+{
+  return w <= x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	fle.d	a5,fa0,fa1
+	czero.eqz	a0,a0,a5
+	czero.nez	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fge\\.d|fle\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.eqz\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.nez\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsiflt-sfb.c b/gcc/testsuite/gcc.target/riscv/movsiflt-sfb.c
new file mode 100644
index 00000000000..110e38a49e6
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsiflt-sfb.c
@@ -0,0 +1,26 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc -mtune=sifive-7-series -mbranch-cost=1 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsiflt (double w, double x, int_t y, int_t z)
+{
+  return w < x ? y : z;
+}
+
+/* Expect short forward branch assembly like:
+
+	flt.d	a5,fa0,fa1
+	bne	a5,zero,1f	# movcc
+	mv	a0,a1
+1:
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:beq|bne)\\s\[^\\s\]+\\s# movcc\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsiflt-thead.c b/gcc/testsuite/gcc.target/riscv/movsiflt-thead.c
new file mode 100644
index 00000000000..124c408718b
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsiflt-thead.c
@@ -0,0 +1,25 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" } } */
+/* { dg-options "-march=rv64gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc_xtheadcondmov -mtune=thead-c906 -mbranch-cost=1 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsiflt (double w, double x, int_t y, int_t z)
+{
+  return w < x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	flt.d	a5,fa0,fa1
+	th.mveqz	a0,a1,a5
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\s(?:th\\.mveqz|th\\.mvnez)\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsiflt-ventana.c b/gcc/testsuite/gcc.target/riscv/movsiflt-ventana.c
new file mode 100644
index 00000000000..911a5029dda
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsiflt-ventana.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target rv64 } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_xventanacondops -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsiflt (double w, double x, int_t y, int_t z)
+{
+  return w < x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	flt.d	a5,fa0,fa1
+	vt.maskc	a0,a0,a5
+	vt.maskcn	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskc\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\svt\\.maskcn\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/movsiflt-zicond.c b/gcc/testsuite/gcc.target/riscv/movsiflt-zicond.c
new file mode 100644
index 00000000000..7db2b994fc5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/riscv/movsiflt-zicond.c
@@ -0,0 +1,28 @@
+/* { dg-do compile } */
+/* { dg-skip-if "" { *-*-* } { "-O0" "-Og" "-Os" "-Oz" } } */
+/* { dg-options "-march=rv64gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" { target { rv64 } } } */
+/* { dg-options "-march=rv32gc_zicond -mtune=rocket -mbranch-cost=3 -fdump-rtl-ce1" { target { rv32 } } } */
+
+typedef int __attribute__ ((mode (SI))) int_t;
+
+int_t
+movsiflt (double w, double x, int_t y, int_t z)
+{
+  return w < x ? y : z;
+}
+
+/* Expect branchless assembly like:
+
+	flt.d	a5,fa0,fa1
+	czero.eqz	a0,a0,a5
+	czero.nez	a5,a1,a5
+	or	a0,a5,a0
+ */
+
+/* { dg-final { scan-rtl-dump-times "Conversion succeeded on pass 1\\." 1 "ce1" } } */
+/* { dg-final { scan-rtl-dump-not "if-conversion succeeded through" "ce1" } } */
+/* { dg-final { scan-assembler-times "\\s(?:fgt\\.d|flt\\.d)\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.eqz\\s" 1 } } */
+/* { dg-final { scan-assembler-times "\\sczero\\.nez\\s" 1 } } */
+/* { dg-final { scan-assembler-not "\\s(?:beq|bne)\\s" } } */
+/* { dg-final { scan-assembler-not "\\s(?:seqz|snez)\\s" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/smax-ieee.c b/gcc/testsuite/gcc.target/riscv/smax-ieee.c
index 2dbccefe2f4..775e515cf38 100644
--- a/gcc/testsuite/gcc.target/riscv/smax-ieee.c
+++ b/gcc/testsuite/gcc.target/riscv/smax-ieee.c
@@ -10,4 +10,4 @@ smax (double x, double y)
 
 /* { dg-final { scan-assembler-not "\t(call|tail)\tfmax\t" } } */
 /* { dg-final { scan-assembler-not "\tfmax\\.d\t" } } */
-/* { dg-final { scan-assembler "\tfge\\.d\t" } } */
+/* { dg-final { scan-assembler "\t(fge\\.d|flt\\.d)\t" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/smaxf-ieee.c b/gcc/testsuite/gcc.target/riscv/smaxf-ieee.c
index 31b9bfa4d91..c794bc3b02f 100644
--- a/gcc/testsuite/gcc.target/riscv/smaxf-ieee.c
+++ b/gcc/testsuite/gcc.target/riscv/smaxf-ieee.c
@@ -10,4 +10,4 @@ smaxf (float x, float y)
 
 /* { dg-final { scan-assembler-not "\t(call|tail)\tfmaxf\t" } } */
 /* { dg-final { scan-assembler-not "\tfmax\\.s\t" } } */
-/* { dg-final { scan-assembler "\tfge\\.s\t" } } */
+/* { dg-final { scan-assembler "\t(fge\\.s|flt\\.s)\t" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/smin-ieee.c b/gcc/testsuite/gcc.target/riscv/smin-ieee.c
index ea36c2de89f..28cedd3bea5 100644
--- a/gcc/testsuite/gcc.target/riscv/smin-ieee.c
+++ b/gcc/testsuite/gcc.target/riscv/smin-ieee.c
@@ -10,4 +10,4 @@ smin (double x, double y)
 
 /* { dg-final { scan-assembler-not "\t(call|tail)\tfmin\t" } } */
 /* { dg-final { scan-assembler-not "\tfmin\\.d\t" } } */
-/* { dg-final { scan-assembler "\tfle\\.d\t" } } */
+/* { dg-final { scan-assembler "\t(fgt\\.d|fle\\.d)\t" } } */
diff --git a/gcc/testsuite/gcc.target/riscv/sminf-ieee.c b/gcc/testsuite/gcc.target/riscv/sminf-ieee.c
index 427617af08f..18d485865e1 100644
--- a/gcc/testsuite/gcc.target/riscv/sminf-ieee.c
+++ b/gcc/testsuite/gcc.target/riscv/sminf-ieee.c
@@ -10,4 +10,4 @@ sminf (float x, float y)
 
 /* { dg-final { scan-assembler-not "\t(call|tail)\tfminf\t" } } */
 /* { dg-final { scan-assembler-not "\tfmin\\.s\t" } } */
-/* { dg-final { scan-assembler "\tfle\\.s\t" } } */
+/* { dg-final { scan-assembler "\t(fgt\\.s|fle\\.s)\t" } } */
-- 
2.25.1

